<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<# int argumentCount = 16; #>
// ReSharper disable UnusedAutoPropertyAccessor.Global
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable ArrangeConstructorOrDestructorBody
namespace Stl.Interception;

public partial record ArgumentList
{
    public readonly ArgumentList Empty = new ();

    public virtual int Length => 0;

    public object? this[int index]
    {
      get {
        if (index < 0 || index >= Length)
            throw new ArgumentOutOfRangeException(nameof(index));
        return GetItem(index);
      }
    }

    protected virtual object? GetItem(int index)
        => throw new NotSupportedException();

<# for(int i = 1; i<=argumentCount; i++) {
   string argumentTypes = "" ;
   string argumentDeclaration = "";
   string argumentUsage = "";
   for (int t = 0; t < i; t++) {
       if (t > 0)
           argumentTypes += ", ";
       argumentTypes += ("T" + t);

       if (t > 0)
           argumentDeclaration += ", ";
       argumentDeclaration += ("T" + t + " item" + t);

       if (t > 0)
           argumentUsage += ", ";
       argumentUsage += ("item" + t);
   }
#>
    public static ArgumentList<<#=argumentTypes#>> New<<#=argumentTypes#>>(<#=argumentDeclaration#>)
        => new (<#=argumentUsage#>);

<#}#>
    protected ArgumentList() {}
}

<# for(int i = 1; i<=argumentCount; i++) {
   string argumentTypes = "" ;
   string argumentDeclaration = "";
   for (int t = 0; t < i; t++) {
       if (t > 0)
           argumentTypes += ", ";
       argumentTypes += ("T" + t);

       if (t > 0)
           argumentDeclaration += ", ";
       argumentDeclaration += ("T" + t + " item" + t);
   }
#>
public sealed record ArgumentList<<#=argumentTypes#>> : ArgumentList, IEquatable<ArgumentList<<#=argumentTypes#>>>
{
    public override int Length => <#=i#>;

<#for (int t = 0; t < i; t++) {#>
    public T<#=t#> Item<#=t#> { get; }
<#}#>

    protected override object? GetItem(int index)
        => index switch {
<#for (int t = 0; t < i; t++) {#>
            <#=t#> => Item<#=t#>,
<#}#>
            _ => throw new ArgumentOutOfRangeException(nameof(index))
        };

    public bool Equals(ArgumentList<<#=argumentTypes#>>? other)
    {
        if (other == null)
            return false;
<#for (int t = 0; t < i; t++) {#>
        if (Item<#=t#> is not CancellationToken && !EqualityComparer<T<#=t#>>.Default.Equals(Item<#=t#>, other.Item<#=t#>)) return false;
<#}#>
        return true;
    }

    public override int GetHashCode()
    {
        unchecked {
            var hashCode = Item0 is CancellationToken || Item0 is null ? 0 : EqualityComparer<T0>.Default.GetHashCode(Item0);
<#for (int t = 1; t < i; t++) {#>
            hashCode = (hashCode * 397) + (Item<#=t#> is CancellationToken || Item<#=t#> is null ? 0 : EqualityComparer<T<#=t#>>.Default.GetHashCode(Item<#=t#>));
<#}#>
            return hashCode;
        }
    }

    public bool Equals(ArgumentList<<#=argumentTypes#>>? other, Delegate?[] equalDelegates)
    {
        if (equalDelegates.Length != <#=i#>)
            throw new ArgumentOutOfRangeException(nameof(equalDelegates));
        if (other == null)
            return false;
<#for (int t = 0; t < i; t++) {#>
        if (equalDelegates[<#=t#>] is Func<T<#=t#>, T<#=t#>, bool> func<#=t#>) {
            if (!func<#=t#>.Invoke(Item<#=t#>, other.Item<#=t#>))
                return false;
        }
        else if (!EqualityComparer<T<#=t#>>.Default.Equals(Item<#=t#>, other.Item<#=t#>)) {
            return false;
        }

<#}#>
        return true;
    }

    public int GetHashCode(Delegate?[] getHashCodeDelegates)
    {
        if (getHashCodeDelegates.Length != <#=i#>)
            throw new ArgumentOutOfRangeException(nameof(getHashCodeDelegates));
        unchecked {
            int hashCode;
            if (getHashCodeDelegates[0] is Func<T0, int> func0)
                hashCode = func0(Item0);
            else
                hashCode = Item0 is null ? 0 : EqualityComparer<T0>.Default.GetHashCode(Item0);

<#for (int t = 1; t < i; t++) {#>
            if (getHashCodeDelegates[<#=t#>] is Func<T<#=t#>, int> func<#=t#>)
                hashCode = (hashCode * 397) + func<#=t#>(Item<#=t#>);
            else
                hashCode = (hashCode * 397) + (Item<#=t#> is null ? 0 : EqualityComparer<T<#=t#>>.Default.GetHashCode(Item<#=t#>));

<#}#>
            return hashCode;
        }
    }

    public ArgumentList(<#=argumentDeclaration#>)
    {
<#for (int t = 0; t < i; t++) {#>
        Item<#=t#> = item<#=t#>;
<#}#>
    }
}

<#}#>
