<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" encoding="utf-8" #>
<#@ assembly Name="System.Core.dll" #>
<#
    const int maxItemCount = 16;
#>
using System.Diagnostics.CodeAnalysis;

namespace ActualLab.Collections.Fixed;

#pragma warning disable CS0169 // Field is never used
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
<#
    for (var itemCount = 1; itemCount <= maxItemCount; itemCount++)
    {
        var className = $"FixedArray{itemCount}<T>";
        var ctorName = $"FixedArray{itemCount}";
#>

[StructLayout(LayoutKind.Sequential, Pack = 1)] // Important!
public struct <#= className #> : IEquatable<<#= className #>>
{
#if !NETSTANDARD2_0
<#
    for (var i = 0; i < itemCount; i++) {
#>
    private T _item<#= i #>;
<#
    }
#>

<#
    for (var i = 0; i < itemCount; i++) {
#>
    public T Item<#= i #> {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => _item<#= i #>;
    }
<#
    }
#>

    public Span<T> Span {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => MemoryMarshal.CreateSpan(ref _item0, <#= itemCount #>);
    }

    public ReadOnlySpan<T> ReadOnlySpan {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => MemoryMarshal.CreateReadOnlySpan(ref _item0, <#= itemCount #>);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= className #> New() => new();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= className #> New(params ReadOnlySpan<T> source) => new(in source);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#= ctorName #>(in ReadOnlySpan<T> source)
        => source.CopyTo(Span);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#= ctorName #>(T[] items)
        => items.CopyTo(Span);
#else
    private readonly T[] _items;

<#
    for (var i = 0; i < itemCount; i++) {
#>
    public T Item<#= i #> {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => _items[<#= i #>];
    }
<#
    }
#>

    public Span<T> Span {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => _items.AsSpan();
    }

    public ReadOnlySpan<T> ReadOnlySpan {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => _items.AsSpan();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= className #> New() => new(new T[<#= itemCount #>]);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= className #> New(params ReadOnlySpan<T> source) => new(in source);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#= ctorName #>(in ReadOnlySpan<T> source)
    {
        _items = new T[<#= itemCount #>];
        source.CopyTo(_items);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#= ctorName #>(T[] items)
        => _items = items;
#endif

    // Equality

    public override bool Equals([NotNullWhen(true)] object? obj)
        => obj is <#= className #> other && Equals(other);

    public bool Equals(<#= className #> other)
    {
        var comparer = EqualityComparer<T>.Default;
#if !NETSTANDARD2_0
        return
            comparer.Equals(_item0, other._item0)
<#
    for (var i = 1; i < itemCount; i++) {
#>
            && comparer.Equals(_item<#= i #>, other._item<#= i #>)
<#
    }
#>
            ;
#else
        var otherItems = other._items;
        for (var i = 0; i < _items.Length; i++)
            if (!comparer.Equals(_items[i], otherItems[i]))
                return false;

        return true;
#endif
    }

    public override int GetHashCode()
    {
#if !NETSTANDARD2_0
        var hashCode = _item0?.GetHashCode() ?? 0;
<#
    for (var i = 1; i < itemCount; i++) {
#>
        hashCode = (359 * hashCode) + _item<#= i #>?.GetHashCode() ?? 0;
<#
    }
#>
#else
        var hashCode = 0;
        foreach (var item in _items)
            hashCode = (359 * hashCode) + item?.GetHashCode() ?? 0;
#endif
        return hashCode;
    }

    public static bool operator ==(<#= className #> left, <#= className #> right) => left.Equals(right);
    public static bool operator !=(<#= className #> left, <#= className #> right) => !left.Equals(right);
}
<#
    }
#>
