using Cysharp.Text;
using Stl.Fusion.Bridge.Internal;
using Stl.Fusion.Interception;
using Stl.Fusion.Internal;
using Stl.Versioning;

namespace Stl.Fusion.Bridge.Interception;

public interface IReplicaMethodFunction : IComputeMethodFunction
{
    IReplicator Replicator { get; }
}

public class ReplicaMethodFunction<T> : ComputeFunctionBase<T>, IReplicaMethodFunction
{
    private string? _toString;

    public VersionGenerator<LTag> VersionGenerator { get; }
    public IReplicator Replicator { get; }

    public ReplicaMethodFunction(
        ComputeMethodDef methodDef,
        IReplicator replicator,
        VersionGenerator<LTag> versionGenerator)
        : base(methodDef, ((IReplicatorImpl) replicator).Services)
    {
        Replicator = replicator;
        VersionGenerator = versionGenerator;
    }

    public override string ToString()
        => _toString ??= ZString.Concat('*', base.ToString());

    protected override async ValueTask<Computed<T>> Compute(
        ComputedInput input, Computed<T>? existing,
        CancellationToken cancellationToken)
    {
        var typedInput = (ComputeMethodInput) input;
        if (existing is not ReplicaMethodComputed<T> { Replica: { State: { } state } replica }) {
            // No ReplicaMethodComputed or it doesn't have a replica or state  
            return await RenewReplica(typedInput, cancellationToken).ConfigureAwait(false);
        }

        if (!state.IsConsistent) {
            // Every time we call Update on replica, it calls RequestUpdate automatically
            // if the state is consistent, which delivers invalidations.
            // But here we request an update when the state is inconsistent,
            // i.e. here we request the new data _after_ the invalidation.
            await replica.RequestUpdate().WaitAsync(cancellationToken).ConfigureAwait(false);
        }

        var computed = replica.RenewComputed(typedInput, CreateComputed);
        if (computed == null) {
            // Two cases are possible here:
            // - Replica is there, but its State == null, i.e. it is disposed
            // - Replica.State.Output == null, i.e. somehow it didn't get any
            //   update that contains it & had no Output from the very beginning
            //   (they retain the output while possible).
            // In any of these cases all we can do is to renew it.
            return await RenewReplica(typedInput, cancellationToken).ConfigureAwait(false);
        }

        ComputeContext.Current.TryCapture(computed);
        return computed;
    }

    private async Task<Computed<T>> RenewReplica(
        ComputeMethodInput input, CancellationToken cancellationToken)
    {
        while (true) {
            var publicationState = await InvokeRemoteFunction(input, cancellationToken).ConfigureAwait(false);

            var computed = publicationState.PublicationRef.IsNone 
                ? new ReplicaMethodComputed<T>(input.MethodDef.ComputedOptions, input, null, publicationState) 
                : Replicator.AddOrUpdate(publicationState).RenewComputed(input, CreateComputed);
            if (computed != null) {
                ComputeContext.Current.TryCapture(computed);
                return computed;
            }

            DebugLog?.LogError("RenewReplica: the replica was disposed right after it was created, retrying...");
        }
    }

    private async Task<PublicationStateInfo<T>> InvokeRemoteFunction(
        ComputeMethodInput input, CancellationToken cancellationToken)
    {
        Result<T> output;
        using var publicationStateCapture = new PublicationStateInfoCapture();
        try {
            var rpcResult = input.InvokeOriginalFunction(cancellationToken);
            if (input.MethodDef.ReturnsValueTask) {
                var rpcResultTask = (ValueTask<T>)rpcResult;
                output = Result.Value(await rpcResultTask.ConfigureAwait(false));
            }
            else {
                var rpcResultTask = (Task<T>)rpcResult;
                output = Result.Value(await rpcResultTask.ConfigureAwait(false));
            }
        }
        catch (Exception e) when (e is not OperationCanceledException) {
            DebugLog?.LogError(e, "Compute: failed to fetch the initial value");
            if (e is AggregateException ae)
                e = ae.GetFirstInnerException();
            output = Result.Error<T>(e);
        }

        var publicationState = publicationStateCapture.Captured;
        if (publicationState != null)
            return new PublicationStateInfo<T>(publicationState, output);

        // No PublicationStateInfo is captured, so... 
        output = new Result<T>(default!, Errors.NoPublicationStateInfo());
        // A unique version tha cannot be generated by LTagGenerators
        var version = new LTag(VersionGenerator.NextVersion().Value ^ (1L << 62));
        return new PublicationStateInfo<T>(PublicationRef.None, version, false, output);
    }

    private static ReplicaMethodComputed<T> CreateComputed(
        Replica<T> replica, 
        PublicationStateInfo<T> state, 
        ComputeMethodInput input) 
        => new (input.MethodDef.ComputedOptions, input, replica, state);
}
