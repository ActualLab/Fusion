using Cysharp.Text;
using Stl.Fusion.Bridge.Internal;
using Stl.Fusion.Interception;
using Stl.Fusion.Internal;
using Stl.Versioning;

namespace Stl.Fusion.Rpc.Internal;

public interface IRpcComputeMethodFunction : IComputeMethodFunction
{
    void OnInvalidated(IRpcComputed computed);
}

public class RpcComputeMethodFunction<T> : ComputeFunctionBase<T>, IRpcComputeMethodFunction
{
    private string? _toString;

    public VersionGenerator<LTag> VersionGenerator { get; }
    public RpcComputedCache RpcComputedCache { get; }

    public RpcComputeMethodFunction(
        ComputeMethodDef methodDef,
        VersionGenerator<LTag> versionGenerator,
        RpcComputedCache cache,
        IServiceProvider services)
        : base(methodDef, services)
    {
        VersionGenerator = versionGenerator;
        RpcComputedCache = cache;
    }

    public override string ToString()
        => _toString ??= ZString.Concat('*', base.ToString());

    public void OnInvalidated(IRpcComputed computed)
        => _ = RpcComputedCache.Set<T>((ComputeMethodInput)computed.Input, null, CancellationToken.None);

    protected override ValueTask<Computed<T>> Compute(
        ComputedInput input, Computed<T>? existing,
        CancellationToken cancellationToken)
    {
        throw new NotSupportedException();
        /*
        var typedInput = (ComputeMethodInput)input;
        return existing == null
            ? CachedCompute(typedInput, cancellationToken)
            : RpcCompute(typedInput, cancellationToken).ToValueTask();
        */
    }

#if false
    private async ValueTask<Computed<T>> CachedCompute(
        ComputeMethodInput input,
        CancellationToken cancellationToken)
    {
        var outputOpt = await RpcComputedCache.Get<T>(input, cancellationToken).ConfigureAwait(false);
        if (outputOpt is not { } output)
            return await RpcCompute(input, cancellationToken).ConfigureAwait(false);

        var publicationState = CreateFakePublicationState(output);
        var computed = new ReplicaMethodComputed<T>(input.MethodDef.ComputedOptions, input, null, publicationState);

        // Start the task to retrieve the actual value
        using var _1 = ExecutionContextExt.SuppressFlow();
        _ = Task.Run(() => RpcCompute(input, cancellationToken), CancellationToken.None);
        return computed;
    }

    private async Task<Computed<T>> RpcCompute(ComputeMethodInput input, CancellationToken cancellationToken)
    {
        while (true) {
            var publicationState = await InvokeRemoteFunction(input, cancellationToken).ConfigureAwait(false);
            var computed = publicationState.PublicationRef.IsNone
                ? new ReplicaMethodComputed<T>(input.MethodDef.ComputedOptions, input, null, publicationState)
                : Replicator.AddOrUpdate(publicationState).RenewComputed(input, CreateComputed);
            if (computed != null) {
                // We don't await the next call to speed up returning the result
                _ = RpcComputedCache.Set<T>(input, computed.Output, CancellationToken.None);
                return computed;
            }

            DebugLog?.LogError("RenewReplica: the replica was disposed right after it was created, retrying...");
        }
    }

    private async Task<PublicationStateInfo<T>> InvokeRemoteFunction(
        ComputeMethodInput input, CancellationToken cancellationToken)
    {
        Result<T> output;
        using var publicationStateCapture = new PublicationStateInfoCapture();
        try {
            var rpcResult = input.InvokeOriginalFunction(cancellationToken);
            if (input.MethodDef.ReturnsValueTask) {
                var rpcResultTask = (ValueTask<T>)rpcResult;
                output = Result.Value(await rpcResultTask.ConfigureAwait(false));
            }
            else {
                var rpcResultTask = (Task<T>)rpcResult;
                output = Result.Value(await rpcResultTask.ConfigureAwait(false));
            }
        }
        catch (Exception e) when (e is not OperationCanceledException) {
            DebugLog?.LogError(e, "Compute: failed to fetch the initial value");
            if (e is AggregateException ae)
                e = ae.GetFirstInnerException();
            output = Result.Error<T>(e);
        }

        var publicationState = publicationStateCapture.Captured;
        if (publicationState != null)
            return new PublicationStateInfo<T>(publicationState, output);

        // No PublicationStateInfo is captured, so... 
        output = Result.Error<T>(Errors.NoPublicationStateInfo());
        return CreateFakePublicationState(output);
    }

    private PublicationStateInfo<T> CreateFakePublicationState(Result<T> output)
    {
        // A unique version tha cannot be generated by LTagGenerators
        var version = new LTag(VersionGenerator.NextVersion().Value ^ (1L << 62));
        return new PublicationStateInfo<T>(PublicationRef.None, version, true, output);
    }

    private static ReplicaMethodComputed<T> CreateComputed(
        Replica<T> replica,
        PublicationStateInfo<T> state,
        ComputeMethodInput input)
        => new (input.MethodDef.ComputedOptions, input, replica, state);
#endif
}
